//#region main.js
// --- main.js --- //

import { TwitchChat } from "https://deno.land/x/tmi_beta@v0.1.4/mod.ts";

// =========================================

// twitch bot:
let chat = null, channel = null;
// current scopes generated by https://twitchapps.com/tokengen/:
// https://dev.twitch.tv/docs/authentication/scopes#twitch-access-token-scopes
// channel:moderate moderation:read moderator:read:chat_settings
// moderator:manage:chat_settings moderator:manage:chat_messages
// moderator:manage:announcements moderator:manage:banned_users
// chat:edit chat:read whispers:read whispers:edit
// user:manage:whispers user:manage:chat_color

async function connect() {
	try {
		if (channel !== null) {
			channel.part();
			chat.disconnect();
			log("status", "twitch chat disconnected");
		}
		let token = await Database.get("twitch_oauth_bot");
		if (!(await validate(token))) token = await twitch_refresh();
		chat = new TwitchChat(token);
		await chat.connect();
		channel = chat.join(Streamer, StreamerID);
		channel.listener("privmsg", data => resolve(data, channel));
	} catch (e) {
		console.error(e);
		Deno.exit(1);
	}
	log("status", "twitch chat connected");
}

await connect();

// ==== Announcements ======================

let last = Math.floor(Math.random() * announcements.length);
setInterval(async () => {
	if (announcements.length === 0) return;
	last = (last + 1) % announcements.length;
	const a = announcements[last];
	const message = a.message, color = a.color || "green";
	if (message === undefined) return;
	if ((a.live || true) && !(await live(Streamer))) return;
	channel.commands.announce(message, color);
}, Time.minutes(7));

// =========================================

refresh();

const server = new Server();

server.listen(NOT_FOUND, () => ({ status: 404, body: "Not found" }));

server.listen("refresh", async _request => {
	await refresh();
	return {
		headers: new Headers({ "Content-Type": "text/html" }),
		status: 200, body: "Commands Refreshed!"
	};
});

server.listen([ROOT, "mod"], request => {
	const mod = request.url.includes("mod");
	return {
		headers: new Headers({ "Content-Type": "text/html" }),
		status: 200, body: new TextDecoder().decode(
			Deno.readFileSync("./help.html")
		).replace("`%ACTIONS%`", JSON.stringify(actions))
			.replace("`%PROGRAMMABLES%`", JSON.stringify(programmables))
			.replace("`%PREFIX%`", `'${Prefix}'`)
			.replace("`%MOD%`", JSON.stringify(mod))
	};
});

server.listen("queue", () => {
	const join = programmables.find(p => p.commands.includes("join"));
	return {
		headers: new Headers({ "Content-Type": "text/html" }),
		status: 200, body: new TextDecoder().decode(
			Deno.readFileSync("./queue.html")
		).replace("`%LIST%`", JSON.stringify(queue.list))
			.replace("`%QUEUE%`", queue.enabled ? "'on'" : "'off'")
			.replace("`%CHALLENGE%`", challenge ? "'on'" : "'off'")
			.replace("`%SUBONLY%`", join.permissions === 'sub' ? "'on'" : "'off'")
	};
});

server.listen("validate", async () => {
	let token = await Database.get("twitch_oauth_bot");
	if (!(await validate(token))) token = await twitch_refresh();
	return {
		headers: new Headers({ "Content-Type": "text/html" }),
		status: 200, body: "Token Validated!"
	};
});

server.listen("connect", async () => {
	await connect();
	log("status", "twitch chat connected");
	return {
		headers: new Headers({ "Content-Type": "text/html" }),
		status: 200, body: "twitch chat connected"
	};
});

//====Twitch-Extension============


server.listen("ext", request => {
	let join = programmables.find((p) => p.commands.includes("join"));
	let header = verifyAndDecode(request.headers.authorization);
	let data = JSON.stringify({
		'list': JSON.stringify(queue.list),
		'queue': queue.enabled ? 'on' : 'off',
		'challenge': challenge ? 'on' : 'off',
		'sub_only': join.permissions === 'sub' ? 'on' : 'off'
	});
	// Note that the origin of an extension iframe will be null
	// so the Access-Control-Allow-Origin has to be wildcard.
	return {
		headers: new Headers({
			"Content-Type": "application/json",
			"Access-Control-Allow-Headers": "Content-Type, Authorization, X-Requested-With",
			"Access-Control-Allow-Methods": "OPTIONS, GET, POST",
			"Access-Control-Allow-Origin": "*"
		}),
		status: 200, body: data
	};
});

server.start();
log("status", "server connected");
//#endregion

//#region parser.js
// --- parser.js --- //

let actions = [];
let announcements = [];
const programmables = [];

const log = (component, text) => console.log(
	`[${(new Date()).toLocaleTimeString('en-GB', {
		timeZone: 'UTC', hour12: false, hour: 'numeric', minute: 'numeric'
	})} UTC] ${component}: ${text}`
);

const hearts = { '🧡': "orange", '💚': "green", '💙': "blue", '💜': "purple" };

const handler = message => {
	if (message === undefined) return;
	for (const heart in hearts) if (message.startsWith(heart)) {
		channel.commands.announce(message.substring(1).trim(), hearts[heart]);
		return;
	}
	channel.send(message);
};

// ==== Twitch Actions =========================================================

const RRSLV = new RegExp(`${Prefix}[A-Za-z0-9_\\.]+`, 'i');

function allowed(tags, permissions) {
	if (tags.broadcaster || tags.mod) return true;
	switch (permissions) {
		case 'mod': return false;
		case 'sub': return tags.sub;
		case 'vip': return tags.vip;
		case 'all': default: return true;
	}
}

function resolve(data, channel) {
	if (!data.message.includes(Prefix)) return;
	let command = RRSLV.exec(data.message);
	if (command === null) return;
	if (/\b(command|use|type)\b/i.test(data.message)) return;
	command = command[0].trim().replace(Prefix, '').toLowerCase();
	for (const action of actions) {
		if (!action.commands.includes(command)) continue;
		if (!allowed(data.tags, action.permissions)) return;
		if (action.reply !== undefined) handler(action.reply);
		return;
	}
	for (const action of programmables) {
		if (!action.commands.includes(command)) continue;
		if (!allowed(data.tags, action.permissions)) return;
		if (action.execute.constructor.name === 'AsyncFunction')
			action.execute(data, channel).then(handler);
		else handler(action.execute(data, channel));
		return;
	}
}

async function reloadActions() {
	const A = await Database.get('actions');
	if (A === undefined || A === null) return [];
	return A;
}

async function reloadAnnouncements() {
	const A = await Database.get('announcements');
	if (A === undefined || A === null) return [];
	return A;
}

function programmable(command) {
	if (typeof command.execute !== 'function') return;
	if (command.commands === undefined) return;
	if (typeof command.commands === 'string')
		command.commands = command.commands.split(/\s+/g);
	if (command.permissions === undefined) command.permissions = 'all';
	programmables.push(command);
}

async function refresh() {
	actions = await reloadActions();
	announcements = await reloadAnnouncements();
}
//#endregion 
//#region persistent.js
// --- persistent.js --- //

import { Lock } from "https://deno.land/x/unified_deno_lock@v0.1.1/mod.ts";

const ENDPOINT = Deno.env.get("REPLIT_DB_URL");

class Persistent {

	#key = '';
	#lock = new Lock();

	constructor(key) {
		if (key == undefined || key == null || key == '')
			this.#key = Math.floor(Math.random() * 1000).toString();
		else this.#key = key;
	}

	async get() {
		try {
			const result = await fetch(ENDPOINT + "/" + this.#key);
			if (result.status == 200) return await result.json();
			if (result.status == 404) return undefined;
		} catch (e) { console.error(e); }
		return undefined;
	}
	async set(value) {
		await this.#lock.knock();
		this.#lock.lock();
		try {
			const result = await fetch(ENDPOINT, {
				method: "POST",
				headers: { "Content-Type": "application/x-www-form-urlencoded" },
				body: encodeURIComponent(this.#key) + "=" + encodeURIComponent(JSON.stringify(value)),
			});
			if (result.status == 200) return true;
		}
		catch (e) { console.error(e); }
		finally { this.#lock.unlock(); }
		return false;
	}
	async delete() {
		await this.#lock.knock();
		this.#lock.lock();
		try {
			const result = await fetch(ENDPOINT + "/" + this.#key, {
				method: "DELETE"
			});
			if (result.status == 204) return true;
			if (result.status == 404) return false;
		}
		catch (e) { console.error(e); }
		finally { this.#lock.unlock(); }
		return false;
	}

}
//#endregion
//#region server.js
// --- server.js --- //

import { serve } from 'https://deno.land/std@0.98.0/http/server.ts';

const ROOT = '@', ALL = '*', NOT_FOUND = '404';
const PRX = /(^\/+)|(\/+$)/g;

class Server {

	#server = null;
	#handlers = {};

	constructor(port = 8080) {
		this.#server = serve({ port });
	}

	listen(path, handler) {
		if (Array.isArray(path)) {
			for (const p of path)
				this.#handlers[p.trim().replace(PRX, '').trim()] = handler;
		} else if (typeof path == 'string')
			this.#handlers[path.trim().replace(PRX, '').trim()] = handler;
	}

	async start() {
		if (this.#server === null) return;
		for await (const request of this.#server) {
			// if the path doesn't end with a slash, redirect to the same path with a slash
			if (!request.url.endsWith('/')) {
				request.respond({ status: 301, headers: new Headers({ Location: request.url + '/' }) });
				continue;
			}
			request.url = request.url.trim().replace(PRX, '').trim();
			let response;
			if (request.url in this.#handlers) {
				const handler = this.#handlers[request.url];
				if (handler.constructor.name == 'AsyncFunction')
					response = await handler(request);
				else response = handler(request);
				if (response !== undefined) request.respond(response);
				else request.respond({ status: 200, body: 'OK' });
			} else if (request.url.length === 0) {
				const handler = this.#handlers[ROOT];
				if (handler.constructor.name == 'AsyncFunction')
					response = await handler(request);
				else response = handler(request);
				if (response !== undefined) request.respond(response);
				else request.respond({ status: 200, body: 'OK' });
			} else if (ALL in this.#handlers) {
				const handler = this.#handlers[ALL];
				if (handler.constructor.name == 'AsyncFunction')
					response = await handler(request);
				else response = handler(request);
				if (response !== undefined) request.respond(response);
				else request.respond({ status: 200, body: 'OK' });
			} else if (NOT_FOUND in this.#handlers) {
				const handler = this.#handlers[NOT_FOUND];
				if (handler.constructor.name == 'AsyncFunction')
					response = await handler(request);
				else response = handler(request);
				if (response !== undefined) request.respond(response);
				else request.respond({ status: 404, body: 'OK' });
			} else request.respond({ status: 404 });
		}
	}

}
//#endregion
//#region Database.js
// --- Database.js --- //

const FIREBASE_URL    = Deno.env.get("FIREBASE_URL");
const FIREBASE_SECRET = Deno.env.get("FIREBASE_SECRET");

class Database {

	static async get(key) {
		return await fetch(FIREBASE_URL + encodeURIComponent(key) + "/.json?auth=" + FIREBASE_SECRET)
			.then(e => e.text())
			.then(value => {
				if (!value) return null;
				try { value = JSON.parse(value); }
				catch { return null; }
				if (value === undefined || value === null || value.error !== undefined) return null;
				return value;
			});
	}

	static async set(key, value) {
		await fetch(FIREBASE_URL + encodeURIComponent(key) + "/.json?auth=" + FIREBASE_SECRET, {
			method: "PUT",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(value),
		});
	}

	static async delete(key) {
		await fetch(
			FIREBASE_URL + encodeURIComponent(key) + "/.json?auth=" + FIREBASE_SECRET,
			{ method: "DELETE" }
		);
	}

	static async dictionary() {
		return await fetch(`${FIREBASE_URL}/.json?auth=${FIREBASE_SECRET}`)
			.then(e => e.text())
			.then(value => {
				if (!value) return null;
				try { value = JSON.parse(value); }
				catch { return null; }
				if (value === undefined || value === null || value.error !== undefined) return null;
				return value;
			});
	}

}
//#endregion
//#region Actions
// --- ACTIONS --- //
// --- info.js --- //

programmable({
	commands: [ "restart" ], permissions: "mod",
	description: "Reloads the commands in case of halt.",
	execute: async () => {
		await refresh();
		channel.send(`The bot is restarting.`);
		await connect();
		channel.send(`The bot is back online.`);
	}
});

programmable({
	commands: [ "kill" ], permissions: "mod",
	description: "Kills the bot.",
	execute: () => { Deno.exit(0); }
});

// ==== Challenge ==============================================================

let challenge = false;

programmable({
	commands: [ "challenge" ],
	description: "Challenge Zach to a game.",
	execute: () => challenge ?
		"Zach is accepting challenges today, !join the queue to play him." :
		"Sorry, Zach is not accepting challenges today."
});

programmable({
	commands: [ "togglec" ], permissions: "mod",
	description: "Toggle the challenge message.",
	execute: () => {
		challenge = !challenge;
		return `Challenge mode is currently ${challenge ? "on" : "off"}.`;
	}
});

// ==== Generic Info ===========================================================

programmable({
	commands: [ "time", "timezone" ],
	description: "Gets Zach's current time.",
	execute: () => `For Zach it is ${(new Date()).toLocaleTimeString("en-US", {
		timeZone: "Europe/Amsterdam", //timeZone: "America/Montreal",
		hour12: true, second: "2-digit", minute: "2-digit", hour: "numeric"
	}).replace(/:\d\d ([AP]M)/g, "$1").toLocaleLowerCase()}.`
});

programmable({
	commands: [ "age", "birthday", "bday" ],
	description: "Gets Zach's birthday.",
	execute: () => {
		const d = Date.now() - new Date("30 July 2001");
		const m = new Date(d);
		const a = Math.abs(m.getUTCFullYear() - 1970);
		return `Zach was born on the 30th of July 2001, he is currently ${a}.`;
	}
});

programmable({
	commands: [ "uptime" ],
	description: "Gets the uptime of the stream.",
	execute: async () => {
		const up = await uptime(Streamer);
		if (up === null) return "Zach is not currently streaming.";
		return `Zach has been streaming for ${await uptime(Streamer)}.`
	}
});

programmable({
	commands: [ "followers" ],
	description: "Gets the current number of followers.",
	execute: async () => `Zach has ${await follow_count(Streamer)} followers.`
});

programmable({
	commands: [ "tos" ], permissions: "vip",
	description: "Chess.com terms of service.",
	execute: data => {
		let user = data.message.match(/@(\w+)/);
		if (user === null || user.length < 2)
			return `Please don't suggest moves for the current position ` +
			`as it's against chess.com terms of service!`;
		user = user[1];
		return `@${user} please don't suggest moves for the current position ` +
			`as it's against chess.com terms of service!`;
	}
});

// https://api.2g.be/twitch/followage/thechessnerdlive/user?format=ymwd)
programmable({
	commands: [ "followage" ], permissions: "all",
	description: "Gets your current follow age.",
	execute: async data => {
		const user = data.username;
		if (data.username === Streamer) {
			const d = Time.difference(new Date(), new Date(2022, 2, 19));
			let s = "Zach has been streaming for ";
			if (d.years  > 0) s += `${d.years} years, `;
			if (d.months > 0) s += `${d.months} months, `;
			if (d.weeks  > 0) s += `${d.weeks} weeks, `;
			if (d.days   > 0) s += `${d.days} days.`;
			return s;
		}
		const response = await fetch(
			`https://api.2g.be/twitch/followage/${Streamer}/${user}?format=ymwd`
		);
		if (response.status !== 200) return;
		return '@' + (await response.text()).replace(Streamer + ' ', "");
	}
});


// --- queue.js --- //

const queue = new Queue();

programmable({
	commands: [ 'join' ],
	description: 'Join the current queue.',
	// execute needs to be a function to access `this`.
	execute: async function(data) {
		if (!queue.enabled) return `The queue is closed.`;
		if (this.permissions === 'sub' && !data.tags.sub)
			return `@${data.username}, the queue is currently sub-only.`;
		const username = data.message.match(/join\s+([^ ]+)\s*/i);
		if (username === null || username.length < 2)
			return `@${data.username}, try with ${P}join username`;
		if (username[1].toLowerCase().trim() === 'username')
			return `@${data.username}, really dude? r u 4 real?`;
		if (!(await Chess.com.exists(username[1])))
			return `@${data.username}, there is no Chess.com user "${username[1]}".`;
		const i = await queue.enqueue(data.username, username[1], data.tags.sub || data.tags.mod || data.tags.vip);
		if (i === undefined) return `@${data.username}, you're already in queue.`;
		if (i === null) return `@${username[1]} is already in queue.`;
		const p = "you're " + ordinal(i);
		if (data.username === username[1]) return `"${data.username}" ${p}.`;
		return `@${data.username} aka "${username[1]}" ${p}.`;
	}
});

programmable({
	commands: [ 'leave' ],
	description: 'Leave the current queue.',
	execute: async data => {
		if (await queue.remove(data.username))
			return `@${data.username}, you left the queue.`;
		else return `@${data.username}, you're not in queue.`;
	}
});

programmable({
	commands: [ 'position', 'pos' ],
	description: 'Get your position in the queue.',
	execute: async data => {
		const [ _u, i ] = await queue.position(data.username);
		if (i === null) return `@${data.username}, you're not in queue.`;
		return `@${data.username} you're ${ordinal(i)} / ${await queue.size()}.`;
	}
});

programmable({
	commands: [ 'insert' ], permissions: 'mod',
	description: 'Insert somebody in the current queue.',
	execute: async data => {
		const username = data.message.match(/insert\s+@?(\w+)\s+(\w+)/i);
		if (username === null || username.length < 3)
			return `@${data.username}, try with ${P}insert "twitch" "Chess.com".`;
		if (!(await Chess.com.exists(username[2])))
			return `@${data.username}, there is no Chess.com user "${username[2]}".`;
		const i = await queue.enqueue(username[1], username[2]);
		if (i === undefined || i === null)
			return `@${data.username}, "${username[2]}" is already in queue.`;
		const j = ordinal(i);
		return `@${username[1]} aka "${username[2]}" is ${j}.`;
	}
});

programmable({
	commands: [ 'remove' ], permissions: 'mod',
	description: 'Remove a user from the queue.',
	execute: async data => {
		let username = data.message.match(/remove\s+@?(\w+)/i);
		if (username === null || username.length < 2) return;
		username = username[1].replace(/"|'|@/g, '');
		const result = await queue.remove(username);
		if (result === false) return `${username} is not in queue.`;
		const [ user, profile ] = result;
		if (user === null) return `"${username}" is not in queue.`;
		return `@${user} aka "${profile}" has been removed.`;
	}
});

programmable({
	commands: [ 'next' ], permissions: 'mod',
	description: 'Get the next in line in the queue.',
	execute: async () => {
		const element = await queue.dequeue();
		if (element === undefined) return `The queue is empty.`;
		if (element.user === element.profile) return `"${element.profile}" on Chess.com is next.`;
		return `@${element.user} aka "${element.profile}" on Chess.com is next.`;
	}
});

programmable({
	commands: [ 'queue', 'q' ], permissions: 'mod',
	description: 'Displays the current queue.',
	execute: async () => {
		const list = await queue.list();
		if (list.length === 0) return 'The queue is empty.';
		return 'Queue: ' + list.map(e => e.profile).join(' -> ');
	}
});

programmable({
	commands: [ 'clear' ], permissions: 'mod',
	description: 'Clears the current queue.',
	execute: async () => {
		await queue.clear();
		return 'The queue has been cleared.';
	}
});

programmable({
	commands: [ 'subq' ], permissions: 'mod',
	description: 'Toggles subonly mode for the current queue.',
	execute: () => {
		const join = programmables.find(p => p.commands.includes('join'));
		join.permissions = join.permissions == 'sub' ? 'all' : 'sub';
		return `Sub-only mode is now ${join.permissions == 'sub' ? 'on' : 'off'}.`;
	}
});

programmable({
	commands: [ 'toggleq' ], permissions: 'mod',
	description: 'Toggles the queue on and off.',
	execute: () => {
		queue.enabled = !queue.enabled;
		return `The queue is now ${queue.enabled ? 'open' : 'closed'}.`;
	}
});

// --- ratings.js --- //

import { FIDE } from "https://deno.land/x/fide_rs@v1.0.3/mod.ts";

const emojis = {
	blitz: "⚡️", bullet: "🔫", rapid: "⏱️", classical: "⏳", standard: "🕰",
	daily: "☀️", tactics: "🧩", "puzzle rush": "🔥",
};

const CHESS_COM_REGEX = new RegExp(Prefix + "(?:chess\\.?com|ratings)\\s+<?([A-Za-z0-9_\\-]+)>?");
const PUZZLES_REGEX = new RegExp(Prefix + "puzzles\\s+<?(\\w+)>?");
const LICHESS_REGEX = new RegExp(Prefix + "lichess(?:\\.org)?\\s+<?([A-Za-z0-9_\\-]+)>?");

programmable({
	commands: [ "fide" ], permissions: "all",
	description: "Gets Zach's FIDE official ratings.",
	execute: async () => {
		const player = await FIDE(ZACH_FIDE_ID);
		if (player === undefined || player === null)
			return "Zach's FIDE profile -> ratings.fide.com/profile/" + ZACH_FIDE_ID;
		return `Zach's FIDE ratings (ratings.fide.com/profile/${ZACH_FIDE_ID}) -> ` +
		player.ratings.filter(r => r.rating != "UNR").map(
			r => emojis[r.category] + ` ${r.category} ${r.rating}`
		).join(", ") + '.';
	}
});

programmable({
	commands: [ "personalbest", "pb", "peak", "ath" ], permissions: "all",
	description: "Gets Zach's peak ratings on Chess.com.",
	execute: async () => {
		const ratings = await Chess.com.best("thechessnerd");
		if (ratings === undefined)
			return "Zach's Chess.com profile -> chess.com/member/thechessnerd";
		return "Zach's Chess.com peak ratings -> " + ratings.map(
			r => emojis[r.category] + ` ${r.category} ${r.rating}`
		).join(", ") + '.';
	}
});

programmable({
	commands: [ "puzzles" ], permissions: "all",
	description: "Gets Chess.com puzzle stats for the specified user.",
	execute: async data => {
		const match = data.message.match(PUZZLES_REGEX);
		if (match === null || match.length < 2)
			return `Try with ${Prefix}chess.com <username>.`;
		const ratings = await Chess.com.puzzles(match[1]);
		if (ratings === undefined)
			return `Couldn't find Chess.com user '${match[1]}'.`;
		return saxon_genitive(match[1]) + " Chess.com puzzle stats -> " + ratings.map(
			r => emojis[r.category] + ` ${r.category} ${r.rating}`
		).join(", ") + '.';
	}
});

programmable({
	commands: [ "chess.com", "chesscom", "ratings" ], permissions: "all",
	description: "Gets Chess.com ratings for the specified user.",
	execute: async data => {
		const match = data.message.match(CHESS_COM_REGEX);
		if (match === null || match.length < 2) {
			const ratings = await Chess.com.ratings("thechessnerd");
			if (ratings === undefined)
				return "Zach's Chess.com profile -> chess.com/member/thechessnerd";
			return "Zach's Chess.com ratings -> " + ratings.map(
				r => emojis[r.category] + ` ${r.category} ${r.rating}`
			).join(", ") + '.';
		}
		const ratings = await Chess.com.ratings(match[1]);
		if (ratings === undefined)
			return `Couldn't find Chess.com user '${match[1]}'.`;
		return saxon_genitive(match[1]) + " Chess.com ratings -> " + ratings.map(
			r => emojis[r.category] + ` ${r.category} ${r.rating}`
		).join(", ") + '.';
	}
});

programmable({
	commands: [ "lichess", "lichess.org" ], permissions: "all",
	description: "Gets lichess.org ratings for the specified user.",
	execute: async data => {
		const match = data.message.match(LICHESS_REGEX);
		if (match === null || match.length < 2)
			return `Try with ${Prefix}lichess <username>.`;
		const ratings = await lichess.org.ratings(match[1]);
		if (ratings === undefined)
			return `Couldn't find lichess.org user '${match[1]}'.`;
		return saxon_genitive(match[1]) + " lichess.org ratings -> " + ratings.map(
			r => emojis[r.category] + ` ${r.category} ${r.rating}`
		).join(", ") + '.';
	}
});

programmable({
	commands: [ "starting" ], permissions: "all",
	description: "Gets Zach's starting rating for this stream.",
	execute: async () => {
		const up = await uptime(Streamer);
		if (up === null) return 'Zach is not currently streaming.';
		// fetch the rating from the database.
		let ratings = await Database.get("starting_rating");
		if (ratings === undefined || ratings === null) {
			ratings = await Chess.com.ratings("thechessnerd");
			await Database.set("starting_rating", ratings);
		}
		if (ratings === undefined || ratings === null)
			return "Zach's Chess.com profile -> chess.com/member/thechessnerd";	
		return "Zach's Chess.com starting rating for this stream -> " +
		ratings.map(
			r => emojis[r.category] + ` ${r.category} ${r.rating}`
		).join(", ") + '.';
	}
});

// --- video.js --- //

programmable({
	commands: [ "video", "newvid", "newvideo" ],
	description: "Gets Zach's current video link.",
	execute: async () => "Check out Zach's new YouTube video: " +
		(await Database.get("yt_video_title")) + " -> " +
		(await Database.get("yt_video_link"))
});
//#endregion Actions
//#region Components
// --- COMPONENTS --- //
// --- chess.com.js --- //

class Chess {

	static com = {

		profile: async user => {
			user = encodeURIComponent(user);
			const url = 'https://api.chess.com/pub/player/';
			try {
				const response = await fetch(url + user);
				if (response.status != 200) return null;
				return await response.json();
			} catch { return null; }
		},

		stats: async user => {
			user = encodeURIComponent(user);
			const url = `https://api.chess.com/pub/player/${user}/stats`;
			try {
				const response = await fetch(url);
				if (response.status != 200) return null;
				return await response.json();
			} catch { return null; }
		},

		ratings: async user => {
			const categories = [ 'rapid', 'blitz', 'bullet' ];
			const ratings = [];
			const chess_com = await Chess.com.stats(user);
			if (chess_com == null) return undefined;
			for (const category of categories) {
				const key = 'chess_' + category;
				if (chess_com[key] == undefined ||
					chess_com[key].last == undefined ||
					chess_com[key].last.rating == undefined) continue;
				const rating = { category, rating: 'unrated' };
				if (!isNaN(parseInt(chess_com[key].last.rating)))
					rating.rating = chess_com[key].last.rating;
				ratings.push(rating);
			}
			return ratings;
		},

		best: async user => {
			const categories = [ 'rapid', 'blitz', 'bullet' ];
			const ratings = [];
			const chess_com = await Chess.com.stats(user);
			if (chess_com == null) return undefined;
			for (const category of categories) {
				const key = 'chess_' + category;
				if (chess_com[key] == undefined ||
					chess_com[key].best == undefined ||
					chess_com[key].best.rating == undefined) continue;
				const rating = { category, rating: 'unrated' };
				if (!isNaN(parseInt(chess_com[key].best.rating)))
					rating.rating = chess_com[key].best.rating;
				ratings.push(rating);
			}
			return ratings;
		},

		puzzles: async user => {
			const ratings = [];
			const chess_com = await Chess.com.stats(user);
			if (chess_com == null) return undefined;
			if (chess_com['tactics'] != undefined &&
				chess_com['tactics'].highest != undefined &&
				chess_com['tactics'].highest.rating != undefined &&
				!isNaN(parseInt(chess_com['tactics'].highest.rating))) ratings.push({
					category: 'tactics', rating: chess_com['tactics'].highest.rating
			});
			if (chess_com['puzzle_rush'] != undefined &&
				chess_com['puzzle_rush'].best != undefined &&
				chess_com['puzzle_rush'].best.score != undefined &&
				!isNaN(parseInt(chess_com['puzzle_rush'].best.score))) ratings.push({
					category: 'puzzle rush', rating: chess_com['puzzle_rush'].best.score
			});
			return ratings;
		},

		exists: async user => {
			user = encodeURIComponent(user);
			const url = `https://api.chess.com/pub/player/${user}/stats`;
			try {
				const response = await fetch(url);
				return (response.status == 200);
			} catch { return false; }
		},

		/// gets daily game from chess.com given its
		/// id returns undefined in case of error.
		daily: async id => {
			const API_BASE_URL = 'https://www.chess.com/callback/daily/game/';
			let g = undefined;
			try {
				g = await fetch(API_BASE_URL + id).then(
					r => r.status == 200 ? r.json() : undefined
				);
			} catch { return undefined; }
			if (g == undefined) return undefined;
			g.game.moveList = moves(g.game.moveList);
			return g.game;
		},

		/// gets live game from chess.com given its
		/// id returns undefined in case of error.
		live: async id => {
			const API_BASE_URL = 'https://www.chess.com/callback/live/game/';
			let g = undefined;
			try {
				g = await fetch(API_BASE_URL + id).then(
					r => r.status == 200 ? r.json() : undefined
				);
			} catch { return undefined; }
			if (g == undefined) return undefined;
			g.game.moveList = moves(g.game.moveList);
			return g.game;
		}

	};

}

// MOVES:

// https://github.com/andyruwruw/chess-web-api/issues/10#issuecomment-779735204
const S = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!?';
const FILES = 'abcdefgh';

// https://github.com/andyruwruw/chess-web-api/issues/11#issuecomment-783687021
const PROMOTIONS = '#@$_[]^()~{}';
const PIECES = 'brnq';

/// decodes a move into algebraic notation or pawn promotion.
/// - move: string of two characters.
function decode(move) {
	let index = S.indexOf(move[0]);
	const f1 = FILES[index % 8], r1 = Math.floor(index / 8) + 1;
	index = S.indexOf(move[1]);
	let p, f2, r2;
	if (index == -1) {
		index = PROMOTIONS.indexOf(move[1]);
		p = PIECES[Math.floor(index / 3)];
		f2 = FILES.indexOf(f1);
		const l = index % 3 == 1, r = index % 3 == 2;
		if (l) f2--; else if (r) f2++; // capture left or right
		f2 = FILES[f2];
		if (r1 == 2) r2 = 1; else r2 = 8;
	} else { f2 = FILES[index % 8]; r2 = Math.floor(index / 8) + 1; }
	return { from: `${f1}${r1}`, to: `${f2}${r2}`, promotion: p };
}

/// decodes a list of moves from a string.
function moves(m) {
	const list = [];
	for (let i = 0; i < m.length; i += 2) {
		const move = decode(m.substring(i, i + 2));
		list.push(move);
	}
	return list;
}

// --- lichess.org.js --- //

class lichess {

	static org = {

		profile: async user => {
			user = encodeURIComponent(user);
			const url = 'https://lichess.org/api/user/';
			try {
				const response = await fetch(url + user);
				if (response.status != 200) return null;
				return await response.json();
			} catch { return null; }
		},

		ratings: async user => {
			const categories = [ 'classical', 'rapid', 'blitz', 'bullet' ];
			const ratings = [];
			const l = await lichess.org.profile(user);
			if (l == null || l.perfs == undefined) return undefined;
			for (const category of categories) {
				if (l.perfs[category] == undefined ||
					l.perfs[category].rating == undefined) continue;
				const rating = { category, rating: 'unrated' };
				if (!isNaN(parseInt(l.perfs[category].rating)))
					rating.rating = l.perfs[category].rating;
				ratings.push(rating);
			}
			return ratings;
		}

	}

}

// --- queue.js --- //

class Queue {

	#queue = null;
	#lock_m = new Lock();
	#lock_d = new Lock();
	enabled = false;

	constructor() { // threadsafe singleton:
		if (!Queue.instance) Queue.instance = this;
		return Queue.instance;
	}

	async #prepare() {
		if (this.#queue !== null) return;
		await this.#lock_d.knock();
		this.#lock_d.lock();
		this.#queue = (await Database.get("queue")) || [];
		this.#lock_d.unlock();
	}

	async #update() {
		this.#prepare();
		await this.#lock_d.knock();
		this.#lock_d.lock();
		await Database.set("queue", this.#queue);
		this.#lock_d.unlock();
	}

	async #enter_critical_section() {
		await this.#lock_m.knock();
		this.#lock_m.lock();
	}

	#leave_critical_section() {
		this.#lock_m.unlock();
	}

	async enqueue(user, profile, sub = false) {
		await this.#prepare();
		await this.#enter_critical_section();
		if (this.#queue.findIndex(e => e.user === user) !== -1) {
			this.#leave_critical_section();
			return undefined;
		}
		if (this.#queue.findIndex(e => e.profile === profile) !== -1) {
			this.#leave_critical_section();
			return null;
		}
		let position;
		if (!sub) {
			this.#queue.push({ user, profile, sub });
			position = this.#queue.length;
		} else {
			let i = 0;
			while (i < this.#queue.length && this.#queue[i].sub) i++;
			this.#queue.splice(i, 0, { user, profile, sub });
			position = i + 1;
		}
		await this.#update();
		this.#leave_critical_section();
		return position;
	}
	async dequeue() {
		await this.#prepare();
		await this.#enter_critical_section();
		if (this.#queue.length === 0) {
			this.#leave_critical_section();
			return undefined;
		}
		const removed = this.#queue.shift();
		await this.#update();
		this.#leave_critical_section();
		return removed;
	}
	async position(user) {
		await this.#prepare();
		const index = this.#queue.findIndex(e => e.user == user);
		if (index === -1) return [ null, null ];
		return [ this.#queue[index], index + 1 ];
	}
	async remove(data) {
		await this.#prepare();
		await this.#enter_critical_section();
		const index = this.#queue.findIndex(
			e => e.user === data || e.profile === data
		);
		if (index === -1) {
			this.#leave_critical_section();
			return false;
		}
		const removed = this.#queue[index];
		this.#queue.splice(index, 1);
		await this.#update();
		this.#leave_critical_section();
		return [ removed.user, removed.profile ];
	}
	async clear() {
		await this.#prepare();
		await this.#enter_critical_section();
		this.#queue = [];
		await this.#update();
		this.#leave_critical_section();
	}

	async list() {
		await this.#prepare();
		return this.#queue || [];
	}

	async size() {
		await this.#prepare();
		return this.#queue.length;
	}

}


// --- twitch.js --- //

// const TWITCH_CLIENT_ID = await Database.get("twitch_client_id");
const TWITCH_APP_ID    = await Database.get("twitch_app_id");
const TWITCH_OAUTH_BOT = await Database.get("twitch_oauth_bot");

const BASE_URL = "https://api.twitch.tv/helix/";
const QUERIES = {
	search: { channel: "search/channels?query=" },
	streams: "streams?user_id=",
	schedule: "schedule?broadcaster_id="
};
const HEADERS = { 
	headers: { 
		"Authorization": "Bearer " + TWITCH_OAUTH_BOT,
		"Client-Id": TWITCH_APP_ID
	} 
};

const buildUrl = uri => BASE_URL + uri;

async function channel(streamer) {
	if (streamer === "") return undefined;
	try {
		const queryUrl = buildUrl(QUERIES.search.channel);
		const req = await fetch(queryUrl + streamer + "&first=1", HEADERS);
		if (req.status != 200) return null;
		const data = (await req.json()).data;
		for (const channel of data)
			if (channel.display_name.toLowerCase() === streamer.toLowerCase())
				return channel;
	} catch { return undefined; }
	return undefined;
}

async function streams(user_ids) {
	if (user_ids.length === 0) return null;
	let data = null;
	try {
		let queryUrl = buildUrl(QUERIES.streams);
		for (let i = 0; i < user_ids.length; i++)
			if (i === user_ids.length - 1) queryUrl += user_ids[i];
			else queryUrl += `${user_ids[i]}&user_id=`;
		const req = await fetch(queryUrl, HEADERS);
		if (req.status != 200) return null;
		data = (await req.json()).data;
	} catch { return undefined; }
	return data;
}

async function live(streamer) {
	const c = await channel(streamer);
	if (c == undefined || c == null) return c;
	return c.is_live;
}

async function schedule(id, date) {
	date = date || new Date().toISOString();
	const url = `${BASE_URL}schedule?broadcaster_id=${id}&start_time=${date}&first=7`;
	try {
		const req = await fetch(url, HEADERS);
		if (req.status != 200) return null;
		const data = (await req.json()).data;
		return data;
	} catch { return null; }
}

async function uptime(streamer) {
	const c = await channel(streamer);
	if (c === undefined || c === null || !c.is_live ||
		c.started_at === undefined || c.started_at === "") return null;
	const s = new Date(c.started_at);
	const e = new Date();
	const d = e.getTime() - s.getTime();
	const h = Math.floor((d % Time.day) / Time.hour);
	const m = Math.floor((d % Time.hour) / Time.minute);
	return h > 0 ? `${h}h ${m}m` : `${m}m`;
}

async function follow_count(streamer) {
	const url = `https://twitchtracker.com/api/channels/summary/${streamer}`;
	try {
		const req = await fetch(url);
		if (req.status != 200) return null;
		const data = await req.json();
		return "followers_total" in data ? data.followers_total : null;
	} catch { return null; }
}

// To validate a token, send an HTTP GET request to https://id.twitch.tv/oauth2/validate.
// The following cURL example shows the request.
// curl -X GET 'https://id.twitch.tv/oauth2/validate' \
// -H 'Authorization: OAuth <token>'
// if the token is not valid, the request returns HTTP status code 401
// docs: https://dev.twitch.tv/docs/authentication/validate-tokens/
async function validate(token) {
	const url = "https://id.twitch.tv/oauth2/validate";
	try {
		const req = await fetch(url, { headers: {
			"Authorization": "OAuth " + token
		} });
		return req.status != 401;
	} catch { return true; } // assumes token is valid
}

async function refresh() {
	const TWITCH_APP_ID     = await Database.get("twitch_app_id");
	const TWITCH_APP_SECRET = await Database.get("twitch_app_secret");
	const TWITCH_REFRESH    = await Database.get("twitch_refresh_token");
	const details = {
		"client_id": TWITCH_APP_ID,
		"client_secret": TWITCH_APP_SECRET,
		"grant_type": "refresh_token",
		"refresh_token": TWITCH_REFRESH
	};
	let formBody = [];
	for (let property in details) {
		let encodedKey = encodeURIComponent(property);
		let encodedValue = encodeURIComponent(details[property]);
		formBody.push(encodedKey + '=' + encodedValue);
	}
	formBody = formBody.join('&');
	const response = await fetch("https://id.twitch.tv/oauth2/token", {
		method: "POST",
		headers: {
			"Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
		},
		body: formBody
	});
	if (response.status != 200) {
		console.error("failed to refresh twitch token");
		return;
	}
	const data = await response.json();
	if (!("scope" in data) || !("access_token" in data) || !("refresh_token" in data)) {
		console.error("refresh twitch token not present");
		return;
	}
	await Database.set("twitch_oauth_bot", data.access_token);
	await Database.set("twitch_refresh_token", data.refresh_token);
	return data.access_token;
}

//#endregion